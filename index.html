<meta charset="utf-8" emacsmode="-*- markdown -*-"><link rel="stylesheet" href="https://casual-effects.com/markdeep/latest/apidoc.css?">

**Understanding Windows x64 Assembly**

Welcome.

For those of you who have decided to take this step closer to the
silicon that powers most of the modern world, I hope this document will help you
just that little bit more when things seem confusing or obtuse. If this document
_itself_ proves to be either of those things, please do contact me and I will
try to remedy such issues.


# Code Repository #

All the source code for this tutorial is available [here](https://github.com/sonictk/asm_tutorial).


# Introduction #

This is _not_ a tutorial for absolute beginners on how to get started with
programming assembly, or a "assembly for dummies" guide.  Rather, it is a set of
notes and observations I have made while on my own journey into the Microsoft
x64 calling conventions that I hope will be useful to others who attempt the
same path. Especially since there seems to a dearth of useful information out
there regarding some of the stumbling blocks I've come across.

If you _are_ looking for a tutorial that will walk through through the basics of
assembly step-by-step, I highly recommend taking a look at the Additional Resources
section.


## Why should I care about assembly? ##

If you've never touched x64 assembly before, it's unlikely that I'll win you
over in a few paragraphs, but let me give my hot take:

* **Dropping to assembly has helped me figure out bugs in release code under
  real production scenarios**. (A particularly nasty one ended up being triggered
  by a driver bug! Thanks, "gaming" drivers.) I've also triaged issues in
  production code from third-party vendors that were sent back to them to
  resolve. External code aside, it's also proven useful to debug issues that
  occurred only in non-debug builds of Maya plugins, for example. And this is
  only with the limited knowledge that I have available! Imagine what you could do
  if you were [Raymond Chen, for example](https://blogs.msdn.microsoft.com/oldnewthing/20180706-00/?p=99185).

* **Possible performance optimizations, or understanding how to modify your code
  to take better advantage of compiler optimizations.** Some programmers resort to
  algorithms and increasing resource usage (threading, GPGPU, etc.) in order to
  achieve better performance; most of the time, there's actually a ton of
  compute being left on the table that could be better utilized instead. There's
  also the fact that if you don't know what to look for in your assembly, you won't
  know exactly if the compiler's doing what you wanted.

* **Ultimately, whatever code you write in whatever language you choose gets
  executed on actual, real hardware**, through abstractions that we take for
  granted. Without understanding assembly, which is a lower-level abstraction
  closer to the hardware/metal, you'll never be able to understand the reasoning
  behind some of your decisions at the higher-level of abstractions. Once you
  have a clear sense of what actually happens on the hardware, it becomes very
  obvious what programming decisions are going to actually help improve
  performance. You'll be able to understand which optimizations are actually
  premature, and which should be done "by default".

* **A better understanding of unexpected behaviour.** Don't understand why your
  code changes are triggering a performance hit or a crash? Profilers can
  only tell you so much; if you understand how assembly works and how the
  compiler generates it, you'll be better equipped to handle odd degenerate
  cases, hardware quirks, or even compiler bugs. The only thing left between you
  and solving the most perplexing of issues will be the hardware itself.


## Requirements ##

This tutorial will focus on writing x64 assembly in Windows. Linux and OSX,
which use the [System V ABI](https://wiki.osdev.org/System_V_ABI) calling
conventions, will not be covered here, as I feel that there is already a
plethora of information out there covering writing assembly on those platforms
already. However, in the event that I find it useful to cover information
regarding those platforms, it will appear in the following format:

!!! tip Crossing the platforms
    Platform-specific information goes here.


### What you will need ###

- A PC running Windows 10.

- A **C/C++ development environment** set up and ready to go. (If you want to see
  what my Emacs setup looks like, it's
  available [here](https://github.com/sonictk/lightweight-emacs).)

- You will need a relatively modern version of **Visual Studio**. I
  will be using 2017 for this tutorial. This may also serve as your C/C++
  development environment, if you so prefer.

- The [Netwide Assembler](https://www.nasm.us/) compiler, for compiling our
  assembly code itself. This tutorial was written using `2.13.03`, but any
  modern version should work.

!!! note Why not MASM?
    On Windows, the officially supported assembly compiler is known as the
    [Microsoft Assembler](https://docs.microsoft.com/en-us/cpp/assembler/masm/masm-for-x64-ml64-exe?view=vs-2017).
    Unfortunately, its feature set is rather limited, especially in the area of
    macros. It's also not really maintained by Microsoft as much these days, and
    so I am using NASM instead, since it has a little more feature-rich macros,
    which I make liberal use of. You are free to practise with MASM instead, but
    I think apart from some basic syntax differences, the concepts are pretty
    much identical and shouldn't be too difficult to port over to NASM.

    To learn how to use MASM, please refer to the [MSDN documentation](https://docs.microsoft.com/en-us/cpp/assembler/masm/microsoft-macro-assembler-reference?view=vs-2017)
    for it.

!!! warning Reliability issues
    I've noticed that NASM's website seems to be rather poor in terms of
    reliability. If you find that the website is down at the time of reading
    this tutorial, please use your Google-fu and try to find mirrors to the
    documentation or the assembler itself. If all else fails, version `2.14` of
    the assembler is
    available
    [here](https://drive.google.com/open?id=1soqbXNtu5LZGUuYiaVEoKY4kMje331ZX)
    and the manual is available [here](https://drive.google.com/open?id=1wEBz7A2pqpvPH0VG7MHhwBBHZrxF5lg4).


<!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="markdeep.min.js" charset="utf-8"></script><script src="https://morgan3d.github.io/markdeep/latest/markdeep.min.js" charset="utf-8"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
